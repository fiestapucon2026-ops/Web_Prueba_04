# Auditoría de Seguridad — OWASP / Serverless Fintech

**Alcance:** Vercel, Supabase, Mercado Pago, Cron-job.org.  
**Criterio:** Código maneja transacciones financieras; asumir atacantes activos.  
**Fecha:** 2026-02-03. **Modo:** Solo hallazgos; sin modificación de código.

---

## Tabla de hallazgos

| Severidad | Archivo / Línea | Descripción del ataque y solución técnica |
|-----------|------------------|--------------------------------------------|
| **Crítica** | `supabase/migrations/*` — tablas `orders`, `inventory`, `job_queue` | **Supabase RLS bypass:** En ninguna migración se hace `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` ni se crean políticas para `orders`, `inventory` o `job_queue`. Si el cliente anon (SUPABASE_ANON_KEY) está expuesto en el cliente o se usa desde un script, un atacante puede: (1) leer todas las órdenes (emails, external_reference, montos), (2) insertar órdenes falsas, (3) leer/modificar la cola de jobs. **Solución:** Habilitar RLS en las tres tablas y crear políticas que den acceso solo a `service_role` (p. ej. `FOR ALL TO service_role USING (true) WITH CHECK (true)`). No exponer service_role en el frontend; el backend ya usa requireSupabaseAdmin(). |
| **Crítica** | `src/app/api/entradas/create-preference/route.ts` (127–147, 257–276) y `src/app/api/tickets/create-preference/route.ts` (95–116, 211–220) | **Condición de carrera (overselling):** El stock se calcula como `total_capacity - count(orders pending|paid)` y luego se insertan órdenes en pasos separados. No hay bloqueo a nivel BD. Con 50 peticiones simultáneas para el último ticket, todas pueden ver stock=1, pasar la comprobación y crear órdenes → se venden 50 entradas para 1 plaza. **Solución:** Garantizar atomicidad en BD: (1) usar una transacción con `SELECT ... FOR UPDATE` sobre el inventario o (2) un único `UPDATE inventory SET total_capacity = total_capacity - :qty WHERE id = :id AND total_capacity >= :qty RETURNING id` y crear la orden solo si se actualizó 1 fila; o (3) constraint/trigger que impida que la suma de (pending+paid) por inventory_id supere total_capacity. |
| **Crítica** | `src/app/api/tickets/create-preference/route.ts` L26, L78–84 | **Idempotencia con cliente anon:** La ruta usa `requireSupabaseClient()` (admin ?? anon). Si en algún entorno solo hay anon, el insert en `idempotency_keys` podría fallar por RLS (solo service_role tiene política), pero la lectura de `inventory` y `orders` y el insert en `orders` no están protegidos por RLS en esas tablas. Además, la clave de idempotencia se reserva con INSERT; entre el SELECT de stock y el INSERT de la orden hay ventana para carrera. **Solución:** Usar siempre `requireSupabaseAdmin()` en esta ruta (y en entradas/create-preference) para órdenes/inventario; y cerrar la condición de carrera como en el ítem anterior. |
| **Alta** | `src/app/api/orders/access-token/route.ts` GET | **IDOR (acceso a entradas ajenas):** Cualquiera que conozca un `external_reference` (UUID) o un `payment_id` de MP puede llamar a `GET /api/orders/access-token?external_reference=<uuid>` o `?payment_id=<id>` y obtener un token válido. Con ese token puede llamar a `by-reference` y ver/imprimir las entradas de esa compra. No se comprueba propiedad (email, cookie, sesión). **Solución:** Exigir prueba de posesión: p. ej. enviar un código por email y validarlo, o limitar el token a un solo uso o vincularlo a un identificador de sesión/cookie firmado generado en /success solo para ese comprador. Alternativamente, no exponer external_reference en URLs públicas; usar solo payment_id tras redirección de MP y acortar ventana de validez. |
| **Alta** | `src/app/api/workers/process-tickets/route.ts` L11–18 | **Timing attack sobre CRON_SECRET:** La comparación del Bearer y del header con el secreto se hace con `===` en JavaScript, que no es constante en tiempo. Un atacante puede medir latencia de respuestas (401 vs 200) para distintos prefijos del token y recuperar el secreto carácter a carácter. **Solución:** Comparar con `crypto.timingSafeEqual(Buffer.from(bearer, 'utf8'), Buffer.from(secret, 'utf8'))` (misma longitud; si longitudes distintas, devolver 401 sin comparar). |
| **Alta** | `src/app/api/webhooks/mercadopago/route.ts` L125–132 | **Payload de prueba MP aceptado sin firma:** Si el body contiene `data.id === '123456'` y `date_created` incluye `'2021-11-01'` (o type payment + id 123456), se responde 200 sin verificar firma. Un atacante no obtiene tickets (no hay external_reference real), pero puede usar este path para probar que el endpoint existe y distinguir respuestas. **Solución:** Mantener la excepción solo para el payload exacto de prueba de MP y no devolver información adicional; opcionalmente restringir por IP si MP publica rangos. |
| **Media** | `src/app/api/workers/process-tickets/route.ts` GET | **Sin rate limit en worker cron:** Cualquiera que conozca (o obtenga por timing/leak) el CRON_SECRET puede llamar al endpoint miles de veces por minuto. Cada llamada procesa hasta 5 jobs. Consecuencias: agotar la cola, saturar Resend/Storage, DoS. **Solución:** Añadir rate limit por IP o por token (p. ej. máximo N llamadas por minuto por origen) o restringir por IP si cron-job.org tiene IPs fijas. |
| **Media** | `src/app/api/orders/by-reference/route.ts` L11–13, L20–29 | **Rate limit en memoria (serverless):** El rate limit usa un `Map` en memoria. En Vercel (serverless) cada invocación puede ser una instancia distinta; el contador no se comparte entre requests. Un atacante puede disparar muchas instancias y superar efectivamente el límite de 30 req/min. **Solución:** Usar rate limit externo (Vercel KV, Upstash Redis, o rate limit por usuario/token en BD) con ventana fija. |
| **Media** | `src/app/api/entradas/create-preference/route.ts` (flujo multi-ítem) | **Mismo patrón de carrera que tickets/create-preference:** Cálculo de stock por ítem en bucle y luego inserción de órdenes; sin atomicidad. **Solución:** Igual que la condición de carrera crítica: transacción/UPDATE atómico o constraint en BD. |
| **Media** | `supabase/migrations/admin_update_daily_inventory_rpc.sql` | **RPC SECURITY DEFINER:** La función `admin_update_daily_inventory` es SECURITY DEFINER y actualiza `daily_inventory` e `inventory`. Si el rol `anon` o `authenticated` tiene EXECUTE en esta función (p. ej. por defectos de Supabase), un atacante podría cambiar stock/precios vía PostgREST sin pasar por el admin. **Solución:** Revocar EXECUTE para anon y authenticated; conceder solo a service_role o al rol usado por el backend. Verificar en Supabase Dashboard → Database → Functions. |
| **Media** | Storage bucket `tickets` | **Lectura pública de PDFs:** La política "Public read tickets" permite SELECT en `storage.objects` donde `bucket_id = 'tickets'`. Cualquier persona con la URL del PDF (p. ej. si se filtra en email o logs) puede descargarlo. **Solución:** Si los PDFs son sensibles, restringir lectura con RLS (p. ej. solo service_role o solo usuarios autenticados que demuestren propiedad del external_reference). URLs firmadas con expiración corta reducen la ventana de abuso. |

---

## Resumen ejecutivo

- **RLS:** Las tablas críticas `orders`, `inventory` y `job_queue` no tienen RLS en las migraciones revisadas; riesgo de lectura/escritura masiva si se usa o filtra la anon key.
- **Race conditions:** La venta de entradas confía en “contar órdenes + insertar” en aplicación; es vulnerable a overselling bajo concurrencia alta. Hace falta atomicidad en base de datos.
- **Webhook MP:** La firma se valida con HMAC y comparación timing-safe; un POST falso con Postman sin el secret correcto no libera tickets. El riesgo principal es el manejo del payload de prueba y la fortaleza del secret.
- **Cron:** Autenticación por Bearer presente pero comparación no constante en tiempo (timing attack) y sin rate limit.
- **IDOR:** El endpoint de access-token permite a quien conozca `external_reference` o `payment_id` obtener token y ver entradas ajenas; no hay verificación de propiedad del comprador.

---

*Documento generado por auditoría estática. No se ha modificado código. Implementar correcciones siguiendo el protocolo de doble confirmación del proyecto.*
