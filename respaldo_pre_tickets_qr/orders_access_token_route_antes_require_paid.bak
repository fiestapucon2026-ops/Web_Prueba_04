import { createAccessToken } from '@/lib/security/access-token';
import { requireSupabaseAdmin } from '@/lib/supabase';
import { NextResponse } from 'next/server';
import { z } from 'zod';

const RATE_LIMIT_REQUESTS = 20;
const RATE_LIMIT_WINDOW_MS = 60_000;
const rateLimitMap = new Map<string, { count: number; resetAt: number }>();

function getClientIp(request: Request): string {
  const forwarded = request.headers.get('x-forwarded-for');
  if (forwarded) return forwarded.split(',')[0]?.trim() ?? 'unknown';
  return request.headers.get('x-real-ip') ?? 'unknown';
}

function isRateLimited(ip: string): boolean {
  const now = Date.now();
  let entry = rateLimitMap.get(ip);
  if (!entry || now >= entry.resetAt) {
    entry = { count: 0, resetAt: now + RATE_LIMIT_WINDOW_MS };
    rateLimitMap.set(ip, entry);
  }
  entry.count++;
  return entry.count > RATE_LIMIT_REQUESTS;
}

const QuerySchemaRef = z.object({
  external_reference: z.string().uuid(),
});
const QuerySchemaPaymentId = z.object({
  payment_id: z.string().min(1),
});

/**
 * Devuelve un token de acceso para "Mis entradas".
 * Acepta external_reference (UUID) o payment_id (collection_id de MP).
 * Si viene payment_id, busca la orden por mp_payment_id (el webhook ya debe haber corrido).
 */
export async function GET(request: Request) {
  try {
    const ip = getClientIp(request);
    if (isRateLimited(ip)) {
      return NextResponse.json({ error: 'Demasiadas solicitudes' }, { status: 429 });
    }

    const url = new URL(request.url);
    const externalRefParam = url.searchParams.get('external_reference');
    const paymentIdParam = url.searchParams.get('payment_id') ?? url.searchParams.get('collection_id');

    let external_reference: string;

    if (externalRefParam) {
      const parsed = QuerySchemaRef.safeParse({ external_reference: externalRefParam });
      if (!parsed.success) {
        return NextResponse.json({ error: 'Par치metro inv치lido' }, { status: 400 });
      }
      external_reference = parsed.data.external_reference;
    } else if (paymentIdParam) {
      const parsed = QuerySchemaPaymentId.safeParse({ payment_id: paymentIdParam });
      if (!parsed.success) {
        return NextResponse.json({ error: 'Par치metro inv치lido' }, { status: 400 });
      }
      const supabase = requireSupabaseAdmin();
      const { data: order, error } = await supabase
        .from('orders')
        .select('external_reference')
        .eq('mp_payment_id', String(parsed.data.payment_id))
        .eq('status', 'paid')
        .limit(1)
        .single();
      if (error || !order?.external_reference) {
        return NextResponse.json({ error: 'No encontrado' }, { status: 404 });
      }
      external_reference = order.external_reference;
    } else {
      return NextResponse.json({ error: 'Falta external_reference o payment_id' }, { status: 400 });
    }

    const token = createAccessToken(external_reference);
    return NextResponse.json({ token });
  } catch (error) {
    console.error('GET /api/orders/access-token error:', error);
    return NextResponse.json({ error: 'Error interno' }, { status: 500 });
  }
}
